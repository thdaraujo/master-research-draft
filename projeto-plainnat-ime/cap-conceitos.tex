%% ------------------------------------------------------------------------- %%
\chapter{Conceitos}
\label{cap:conceitos}

Alguns conceitos teóricos são importantes para o entendimento do presente projeto. Aqui, discutimos os fundamentos mais importantes.

%% ------------------------------------------------------------------------- %%
\section{Aprendizado Supervisionado}
\label{sec:fundamentos}

O aprendizado supervisionado é um tipo de aprendizado de máquina em que o agente, durante a fase de treinamento, observa alguns exemplos de entradas (\textit{inputs}) e de saídas (\textit{outputs}) esperadas e aprende a classificá-las, através de uma função de transformação de entradas em saídas. Depois disso, esse agente observa uma base de testes com inúmeros novos exemplos e deve classificá-los de acordo com o seu modelo interno. Dizemos que um modelo é eficaz se maximiza o conjunto de observações classificadas corretamente e minimiza as observações classificadas incorretamente.

%% ------------------------------------------------------------------------- %%
\section{Conhecimento prévio (\textit{background knowledge})}
\label{sec:fundamentos}

Conhecimento prévio, segundo \citet[capítulo 19]{AIMA}, geralmente é representado como um conjunto geral de teorias em uma lógica de primeira ordem. Essas teorias são compostas por hipóteses que devem explicar ou classificar corretamente um conjunto de observações (ou atributos). Essas observações são sentenças lógicas que descrevem algo sobre o mundo. As hipóteses devem poder ser generalizadas e devem ser aplicáveis a novos exemplos. Outra propriedade importante é que a teoria seja consistente, ou seja, uma hipótese não pode gerar falsos positivos ou falsos negativos.

Esse conhecimento prévio pode ser cumulativo: novas observações podem gerar novas hipóteses, que enriquecem o conhecimento prévio e o modelo como um todo, tornando mais eficaz a sua capacidade de predição e aumentando a generalidade das hipóteses.

Uma das áreas que se concentra nesse tipo de problema de aprendizado é chamada de \textit{Inductive Logic Programming} (ILP), que é uma intersecção entre Aprendizado de Máquina e Programação Lógica. Os programas lógicos são compostos por fatos ou predicados que descrevem exemplos (observações do mundo), conhecimento prévio, e hipóteses. Partindo disto, o programa deriva de forma indutiva um conjunto de novas hipóteses que tenham como consequência lógica todos os exemplos positivos e nenhum dos negativos. Esse conjunto de hipóteses é também chamado de teoria. As novas hipóteses geradas devem ser consistentes com as teorias já presentes no programa. O interessante dessa técnica é o uso de conhecimento prévio definido de uma forma declarativa e compacta, o reaproveitamento de hipóteses e a garantia da consistência.

Com o uso de conhecimento prévio, é reduzida a complexidade do aprendizado, pois as novas hipóteses geradas devem ser consistentes com as hipóteses anteriores, e isso reduz o conjunto de possibilidades que o algoritmo precisaria considerar, além de conseguir explicar parte das novas observações, através do reaproveitamento das hipóteses encontradas ou declaradas anteriormente \citep[capítulo 19]{AIMA}. Por isso, podemos dizer que problemas expressos de forma relacional podem ser tratados muito bem com algoritmos de ILP e com o uso de conhecimento prévio.

%% ------------------------------------------------------------------------- %%
\section{Hierarquia de Representações em Problemas de Aprendizado}
\label{sec:fundamentos}

Segundo \citet{Raedt2008}, existem vários tipos de representações que podem ser utilizadas para modelar um problema de aprendizado. Ele mostra em seu trabalho que também existe uma hierarquia dessas representações em uma ordem crescente de expressividade, exibida a seguir:

\begin{itemize}
    \item \textbf{Representações Booleanas} (\textit{Boolean Learning}): cada percepção contém itens ou proposições verdadeiras (ou \textit{presentes}) e falsas (ou \textit{não-presentes}), e esperamos encontrar uma regra que defina essas observações. Esta é a representação com o menor grau de expressividade.
    \item \textbf{Aprendizado por tabelas de valores e atributos} (\textit{Attribute-Value Learning}): o conjunto de percepções ou experiências é apresentado como uma tabela única onde cada linha é um exemplo e cada coluna é um atributo, e desejamos que o modelo aprenda a classificar uma experiência nova ou a prever o valor de um atributo de acordo com os exemplos vistos anteriormente durante o treinamento. Esse tipo de representação é a mais comumente aplicada na literatura.
    \item \textbf{Representações Multi-Instância} (\textit{Multi-Instance Representations}): muito parecida com a representação por valores e atributos, só que, neste caso, classes podem conter múltiplos exemplos, ou seja, um exemplo pode ter um atributo que depende do valor contido em outro exemplo.
    \item \textbf{Aprendizado Relacional} (\textit{Relational Learning}): múltiplos exemplos ou relações entre exemplos e hipóteses podem aparecer e é possível construir essa representação com múltiplas tabelas em um banco de dados. É bastante útil quando o domínio possui uma natureza relacional.
    \item \textbf{Programas Lógicos} (\textit{Logical Programs}): é um modelo que recebe como entrada as diversas observações (exemplos) e aprende a sintetizar um programa lógico com regras gerais (hipóteses) capazes de derivar estes exemplos e classificar outros conjuntos de observações. Existem alguns trabalhos na literatura cuja linguagem de representação utilizada foi o PROLOG e que usavam ferramentas de ILP. Tal representação é a mais expressiva.
\end{itemize}

Raedt nos mostra ainda que as representações são equivalentes em sua capacidade de representação: um domínio que é representado por uma pode ser adaptado e transformado em outra representação de mais baixo nível e vice-versa. Entretanto, elas não serão equivalentes em sua capacidade de expressão (expressividade): um modelo de mais alto nível será declarativo e compacto, enquanto sua versão de baixo nível vai ser prolixa e vai necessitar de um número muito maior de exemplos, atributos, tabelas, colunas e outras entidades, o que dificulta a análise e a apreciação dessas informações. Portanto, a escolha correta da representação é fundamental para o pesquisador que deseja explorar um problema, pois isto simplifica a análise do domínio.

Raedt também conclui que todas essas representações podem ser modeladas naturalmente com lógica de predicados, que é relacional por natureza. Também dá exemplos de vários algoritmos de aprendizado utilizando programação com lógica,
como \textit{SVMs}, \textit{k-nearest neighbors} e \textit{redes bayesianas}, que podem ser utilizados na modelagem do problema.

%% ------------------------------------------------------------------------- %%
\section{Ontologia}
\label{sec:ontologia}

Diferentemente da noção filosófica de Ontologia como o estudo da natureza do Ser, para a Ciência da Computação uma ontologia é uma estrutura relacional, um modelo de especificação formal explícita de conceitos de um determinado domínio.
Esses conceitos podem dizer respeito a entidades, ou a relações entre entidades desse mesmo domínio.

Segundo \citet{Guarino2009}, uma ontologia é um artefato computacional que possui um modelo formal de representação da estrutura de um domínio, contendo as entidades relevantes, bem como as relações que emergem da observação desse mesmo domínio, porém utilizando apenas as que são úteis para algum determinado fim. A modelagem de classes e relações entre entidades é feita através de definições formais em uma lógica de descrição, de forma compacta e de alto nível de abstração.

Uma ontologia tem por finalidade responder a algumas perguntas, também chamadas de Questões de Competência. No fundo, são informações sobre algum domínio que desejamos que ela nos responda.

Um exemplo de domínio possível é a comunidade científica, com seus diversos pesquisadores e suas relações com os demais. Uma ontologia que representa esse domínio deve ser capaz de capturar as entidades relevantes, organizando as informações em conceitos e relações, para que seja capaz de responder a algumas perguntas, como por exemplo: \textit{Quem é coautor de um artigo A?} Nesse caso, ela pode descrever classes de entidades como \textit{Pesquisador} e \textit{Artigo} e relações binárias entre dois indivíduos, como a relação \textit{colaborou\_com} e \textit{publicou\_artigo}.

O mais importante é que essa definição formal possa ser entendida por um computador em um formato padronizado, para que a resposta seja encontrada de forma automática. Para isso, uma ontologia pode utilizar a inferência lógica para responder a esse tipo de pergunta, como também descobrir novas relações entre entidades, através do uso de \textit{reasoners}, que são programas capazes de inferir consequências lógicas a partir de uma base de fatos.

Por tudo isso, podemos dizer que uma ontologia é uma ferramenta bastante poderosa, capaz de descrever um domínio de forma compacta, permitir consultas complexas e derivar novos conhecimentos de forma automática.

Quanto às questões práticas, existem algumas ferramentas interessantes que
podem ser utilizadas para se trabalhar com ontologias. Uma delas é o Protégé \footnote{\url{http://protege.stanford.edu}},
que é um editor de ontologias \textit{open-source} escrito em Java. O projeto possui uma comunidade bastante ativa, contando com centenas de milhares de usuários, e é utilizado na criação de sistemas inteligentes e na engenharia de ontologias, sendo capaz de armazenar dados em diferentes formatos, como XML, RDF, e até em um banco de dados. Utiliza a OWL-API, uma biblioteca para Java muito utilizada na construção e manipulação de ontologias OWL, descrita por \citet{Horridge:2011:OAJ:2019470.2019471}.

Outra ferramenta interessante é a Tawny-OWL \footnote{Repositório de código da biblioteca Tawny-OWL: \url{https://github.com/phillord/tawny-owl}}, desenvolvida por \citet{DBLP:journals/corr/abs-1303-0213}, que nada mais é que uma linguagem de domínio específico feita para a construção de ontologias OWL que também tem como suporte a OWL-API. Essa biblioteca foi desenvolvida na linguagem de programação Clojure, que é um dialeto de LISP que roda na Java Virtual Machine \citep{hickey2008}. A biblioteca Tawny-OWL possui um conjunto rico de ferramentas extensíveis com um grande poder de abstração. Outra vantagem é a possibilidade do uso de programação paralela e distribuída para o tratamento de grandes volumes de dados, algo que o Clojure suporta muito bem.

%% ------------------------------------------------------------------------- %%
\section{Ontology-Based Data Access}
\label{sec:obda}

Acesso a Dados baseado em Ontologias (Ontology-Based Data Access) é uma forma de
acesso a dados estruturados através do uso de ontologias. A arquitetura desse
tipo de solução inclui uma ontologia que descreve um domínio específico, uma ou
mais bases de dados, e um mapeamento que liga as classes da ontologia com alguns
conjuntos de dados presentes nessas bases de dados. Esse mapeamento transforma
consultas SPARQL em consultas na linguagem utilizada pelo SGBD, seja SQL, noSQL,
ou qualquer outra.
Essa abordagem nasceu para facilitar o acesso e a consulta às bases de dados.


%% ------------------------------------------------------------------------- %%
\section{NoSQL}
\label{sec:nosql}

%TODO
